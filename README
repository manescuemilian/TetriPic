    * Pentru realizarea programului, am folosit doua fisiere sursa:
tema3.c (care contine functia main), si functii.c (in care se afla
declaratiile de functie).

    * Prototipurile functiilor se gasesc in header-ul functii.h.

    * Functia main din tema3.c verifica argumentele de la rularea
programului pentru a vedea ce task sa ruleze. (pentru bonus se
foloseste argumentul 5).

    * Pixelii sunt reprezentati printr-o structura, cu numele pixel,
care are 3 campuri, de tip char, reprezentand cele trei culori: BLUE,
GREEN, RED.

    * Bitmapul e reprezentat printr-o matrice de pixeli, declarata ca
un double pointer, fiind alocata dinamic.

    * Functiile din program:

    - initializare: initializeaza valorile din file si info header,
care vor fi scrise in fisierul binar. Se calculeaza padding-ul
(pointer-ul extra_octeti), lungimea unei linii (cu tot cu padding ->
l_linie), dimensiunea bitmap-ului si dimensiunea intreaga a fisierului
(suma dintre offset si dimensiunea matricii de pixeli).

    - unit: coloreaza o unitate (un patrat) din matricea de pixeli, cu
dimensiunea 10 * 10 pixeli.

    - creeaza_imagine: functie folosita la task-urile 1 si 2,  care
creeaza imaginile cu piesele. Se initializeaza file si info header, se
scriu in fisierul binar, apoi, parcurgand matricea de la ultima linie
spre prima linie, se initializeaza mai intai pixelii cu alb, dupa
care, in functie de piesa data, se coloreaza anumite patrate din
imagine. Se vor scrie in matricea de pixeli. La finalul fiecarei
linii, se adauga padding-ul (extra_octeti).

    - rotire_matrice: roteste imaginile obtinute la functia
precedenta. Acestea se salveaza in matricea R. Se interschimba latimea
si inaltimea imaginilor, si apoi se actualizeaza matricea de pixeli.
Matricea R se aloca pentru valori inverse ale  inaltimii si latimii
tablei de joc. La final se returneaza matricea rotita.

    - padding: calculeaza padding-ul in functie de latimea liniilor
	
    - rotire_piesa: se deschide imaginea formata la task-ul 1, se
citesc header-ele, si se calculeaza doua padding-uri. Extra_octeti_m
este  padding-ul matricei de pixeli curente (inainte de rotire), iar
extra_octeti este padding-ul imaginii de dupa rotire. Variabilele
inaltime_m si latime_m sunt dimensiunile matricii de dinaintea
rotirii. Se apeleaza functia de rotire a matricii. Se apeleaza de 3
ori pentru 90 de grade, deoarece functia roteste matricea cu 90 de
grade in sens trigonometric, si nu orar.

    - este_egal: verifica daca doi pixeli sunt egali

    - este_completa: verifica daca o linie din matrice este completa,
adica daca se gaseste cel putin un pixel care sa fie alb sau negru.

    - mutare_linii: coboara toate liniile negre de deasupra liniei
sterse cu o linie (primul for), iar prima linie neagra de deasupra
chenarului alb va deveni in totalitate neagra  (al doilea for).

    - sterge_linii_complete: parcurge matricea pe linii, si daca
gaseste o linie completa, muta toate liniile de deasupra. Se revine la
inceputul matricei pentru a verifica, din nou, daca exista linii
complete (i = 0).

    - coliziune_patrat: verifica daca sub un patrat se afla un patrat
colorat (care nu e alb sau negru).

    - v_coliziune1: verificarea coliziunilor pentru piesele  I, O, S,
Z, pentru toate unghiurile de rotatie. Pentru fiecare orientare a
pieselor, exista anumite patrate care trebuie sa aiba sub ele patrate
albe sau negre pentru a putea continua coborarea pe tabla de joc
(pentru acestea se verifica prin intermediul functiei
coliziune_patrat).

    - v_coliziune2: aceeasi verificare ca functia precedenta, dar
pentru piesele L, J, T.
	
    * Am impartit verificarea coliziunilor in doua functii din cauza
dimensiunii mari pe care ar fi avut-o functia care sa verifice
coliziunea pentru toate piesele.

    * Aceste doua functii returneaza 1 cand are loc o coliziune, si 0
cand nu.

    - afara_tabla: verifica daca o piesa iese in afara tablei de joc
(daca ajunge in chenarul alb). Se verifica daca cea mai de sus linie a
piesei se afla in chenarul alb (intre liniile 0 - 4).

    * Urmeaza 10 functii, de forma "desenare_culoare", care sunt
folosite pentru a desena piesele pe tabla de joc. Se deseneaza piesele
in functie de unghi, care se da ca parametru. Pana cand piesa ajunge
pe cea mai de jos linie a tablei de joc (while-ul), se deseneaza
piesele in mod repetat, coborand la fiecare iteratie cu cate o linie.
If-else-ul folosit inainte de desenare are rolul de a actualiza tabla
de joc (piesele colorate la mutarea precedenta vor reveni, dupa caz,
albe sau negre). Dupa ce s-a desenat piesa, se verifica daca are loc o
coliziune. In caz afirmativ, se opreste mutarea (break), iar in caz
negativ, piesa mai poate fi mutata in jos pe tabla de joc (lin++).
Daca are loc o coliziune, se verifica si daca piesa iese din tabla de
joc (apelarea functiei afara_tabla). La finalul mutarii piesei (la
finalul fiecarei functii), se sterg liniile complete, daca exista
(sterge_linii_complete).
	
    * Toate aceste functii returneaza 1 daca se iese in afara matricii
de pixeli, si 0 in rest.

    - functia desenare_piesa foloseste functiile anterioare pentru a
desena piesele pe tabla de joc. Returneaza 1 daca se iese in afara, si
0 in rest.

    - creare_tabla: formeaza tabla goala (cu chenarul alb si negru)

    - desenare_tabla3: functia de desenare a tablei pentru task3. Se
citesc datele din fisier, se salveaza in elementele unui vector de
structuri de tip comanda, care este alocat dinamic. Se initializeaza
header-ele, se formeaza tabla de joc (cu chenarul alb si chenarul
negru), iar apoi, pentru fiecare mutare, se verifica daca se intra in
chenarul alb cu o piesa. Ignorarea mutarilor urmatoare se face prin
initializarea i = N. La final, se scriu in imaginea formata header-
ele, pixelii si padding-ul, la finalul fiecarei linii.

    - deseneare_tabla4: pentru task 4. Functioneaza intr-un mod
asemanator cu functia precedenta, dar copiaza elementele din imaginea
de input in imaginea nou formata.

    * Urmatoarele functii sunt pentru task-ul bonus.

    - culoare_patrat, verifica ce culoare are un patrat din imaginea
de input (e suficient sa se verifica primul pixel din patrat pentru a
sti culoarea intregului patrat).

    * Urmeaza din nou 7 functii, cu numele culorii respective,  care
verifica, folosindu-se de de functia culoare_patrat, daca patratele
necesare pentru a forma o piesa au culoarea potrivita. Se verifica
pentru fiecare piesa si pentru fiecare rotatie posibila. Piesele
returneaza 1 cand se gaseste o piesa valida.

    - bonus: functia care scrie in fisierul de output piesele,
unghiurile si coloanele. Se parcurge toata matricea, si se verifica,
pentru fiecare patrat, ce culoare are si din ce piesa face parte. Daca
se gaseste o piesa, variabila numar creste cu 1. La finalul functiei,
se scrie in fisier numarul de piese care a fost gasit.
